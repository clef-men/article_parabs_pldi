\section{Vertex}
\label{sec:parabs_vertex}

\begin{tirPrefix}{vertex-}

At the fourth level, \ocamlinline{Vertex}~\refLibTheoriesFile{zoo_parabs/vertex} implements \emph{DAG-calculus}~\citep{DBLP:conf/icfp/AcarCRS16}, \ie a task graph abstraction.
\Taskflow offers similar, although much more developed, abstractions.
The longer term goal is to support the more practical \Taskflow interface, including static, dynamic, module and condition tasks.

The raison d'Ãªtre of these works is to represent more interesting dependency relations than is possible using standard parallel primitives (\c{fork}/\c{join}, futures, \etc) in order to express irregular parallel computations, \eg those for graph problems.

Concretely, this takes the form of a simple and elegant programming model: a parallel computation is seen as a graph where vertices represent basic sequential computations and edges represent dependencies between vertices.
A vertex can be executed only when its predecessors, \ie dependencies, are finished.
Crucially, the structure of the graph is not static: while executing, a vertex may create new vertices and edges.
Naturally, with great expressivity comes great responsibility: care must be taken not to introduce cycles in the graph, although the model does allow looping on a vertex.

\subsection{Specification}

\input{parabs/figures/vertex_spec}

The specification is given in \cref{fig:parabs_vertex_spec}.
It features no less than six predicates: \inv, \model, \ready, \output, \finished and \predecessor.

The persistent assertion $\inv\ t\ \iProp\ \iPropThree$ represents the knowledge that $t$ is a valid vertex; \iProp is the \emph{non-persistent} output while \iPropThree is the \emph{persistent} output.
It is returned by \c{create} (\refTirName{create-spec}) and required by most operations.

The exclusive assertion $\model\ t\ \v{task}\ \v{iter}$ represents the ownership of vertex $t$.
It is returned by \c{create} (\refTirName{create-spec}).
\v{task} is the current computation attached to $t$; it can accessed using \c{task} (\refTirName{task-spec}) and \c{set\_task} (\refTirName{set-task-spec}).
\v{iter} is the current \emph{logical iteration} of $t$.
Indeed, a vertex may be executed several times; more precisely, a vertex task returns a boolean indicating whether the vertex should be re-executed.

The persistent assertion $\ready\ \v{iter}$ represents the knowledge that the iteration identified by \v{iter} has started --- it may be finished and obsoleted by subsequent iterations.

The assertion $\output\ t\ \iPropTwo$ represents the right to consume \iPropTwo from the non-persistent output of $t$ once the latter has finished executing.
It is returned by \c{create} (\refTirName{create-spec}) with the full non-persistent output and can then be divided using \refTirName{output-divide}.

The persistent assertion $\finished\ t$ represents the knowledge that vertex $t$ has finished executing.
It allows retrieving both the persistent (\refTirName{inv-finished}) and non-persistent (\refTirName{inv-finished-output}) output of $t$.

The persistent assertion $\predecessor\ t\ \v{iter}$ represents the knowledge that iteration \v{iter} has predecessor $t$, \ie \v{iter} can only run once vertex $t$ has finished (\refTirName{predecessor-finished}).
It can be obtained through \c{precede} (\refTirName{precede-spec}), including while the target vertex is executing; in other words, a vertex may add dependencies to itself so that its next iteration only starts when the new dependencies have finished.

The most important operation is \c{release} (\refTirName{release-spec}), which declares a vertex ready for execution, provided that its dependencies (more precisely, those of the corresponding iteration) have finished.
The current task must be shown to execute safely in any execution context given back the possession of the vertex and produce the two outputs.

\subsection{Implementation}

Our implementation is very close to that of \citet{DBLP:conf/icfp/AcarCRS16}.
The representation of a vertex consists of:
(1) the current task,
(2) an atomic counter corresponding to the number of unfinished predecessors,
(3) a closable concurrent stack from \Saturn corresponding to the successors.
When creating a new edge through \c{precede}, the target is added to the successors of the source and the counter of the target is incremented.
After executing, a vertex atomically closes its successors and decrements their counter, releasing those with zero remaining predecessors.

Actually, a vertex counter does not exactly correspond to the number of predecessors.
Before the vertex is released for the first time and during its execution, there is one phantom predecessor preventing premature release; it is removed by \c{release}.

\end{tirPrefix}
