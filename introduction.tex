\Appendices{}{
  \paragraph{Appendices} Per PLDI policy, this version does \emph{not}
  contain our appendix containing detailed benchmark results. The
  anonymous ``supplementary material'' that we submitted contains
  the paper with appendices. We recommend reading it directly.
}

\section{Introduction}

The \OCaml programming language migrated from a sequential to a multicore runtime in \OCamlFive, imported from the \MulticoreOCaml research project~\citep{DBLP:journals/pacmpl/Sivaramakrishnan20} and first released as \OCaml~5.0 in 2022.
The sequential runtime had a ``big runtime lock'' guaranteeing that at most one OCaml thread would run at any point in time.
The multicore runtime supports ``domains'' (heavyweight threads) that can run \OCaml code in parallel, operating on a shared heap and cooperating for garbage collection.
It is designed to offer a M:N threading model with M lightweight tasks (or threads, fibers) are mapped to N domains, with N no larger than the number of CPU cores%
\footnote{
The multicore runtime of OCaml performs frequent stop-the-world pause in its garbage collector, to facilitate the migration of existing programs using the OCaml foreign function interface --- this design does not require adding a read barrier. A consequence of these stop-the-world events is that runtime performance declines sharply if a domain is paused by the operating system, so it is critical to limit the number of domains to available cores: domains are a heavier, less composable abstraction than ``kernel threads'' in typical M:N models. In consequence, they must be controlled by end-used applications, possibly via a concurrency framework that hides them entirely, and software libraries should not implicitly spawn new domains, they need to use a more lightweight task abstraction.
}%
.
The implementation of lightweight tasks and their scheduler is left to be done in userland, as an OCaml library running on top of runtime-provided domains.

The authors of the \MulticoreOCaml runtime implemented the \Domainslib library for CPU-bound tasks, initially to write benchmarks to test the scalability of the \OCaml runtime.
It uses a work-stealing scheduler and is state-of-the-art in the \OCaml library ecosystem.
Other lightweight task libraries include \Moonpool, which was implemented independently, and \Eio which focuses on efficient asynchronous I/O.
All of those schedulers have been used in performance-sensitive scenarios, benchmarked and optimized, notably using lock-free data structures implemented in \OCamlFive.

In this work we present \Parabs, a verified implementation of a state-of-the-art scheduler for lightweight tasks, following the overall design of \Domainslib, with some implementation choices inspired by the \Taskflow \Cpp library~\citep{DBLP:journals/tpds/HuangLLL22}.
This verification builds on top of the \Zoo framework~\citep{AllainS26}, which supports the formal verification of a subset of \OCamlFive in the \Iris program logic~\citep{DBLP:journals/jfp/JungKJBBD18}, mechanized within the Rocq proof assistant.
Our verification effort includes a new mechanized verification of the Chase-Lev work-stealing queue~\citep{DBLP:conf/spaa/ChaseL05}, with stronger invariants than had previously appeared in the literature.
Our scheduler supports two different scheduling strategies, one using standard randomized work-stealing~\citep{DBLP:journals/jacm/BlumofeL99}, the other using work-stealing with \emph{private} deques~\citep{DBLP:conf/ppopp/AcarCR13}.
On top of the scheduler, we expose an API closely resembling \Domainslib, but also a \emph{task graph} abstraction which implements the DAG-calculus of \citet{DBLP:conf/icfp/AcarCRS16}.

This work is focused on formal verification but we did write and run relatively simple benchmarks to validate experimentally that the performance of our verified implementation, \Parabs, is comparable to \Domainslib; in our tests it is equal or faster.

\paragraph{Contributions}

Our contributions include:
\begin{enumerate}
  \item
    A new mechanized verification of the Chase-Lev work-stealing queue~\citep{DBLP:conf/spaa/ChaseL05}, with finer-grained invariants than had previously appeared in the literature.
    In particular, our invariant lets us reason about the failure case of the \c{pop} operation, which was missing from earlier formalizations and is essential to prove termination of the work-stealing scheduler when all task queues are exhausted.
  \item
    A fully verified implementation of a parallel scheduler in \OCamlFive, \Parabs, which provides a verified alternative to the state-of-the-art \Domainslib library.
    To the best of our knowledge, this is the first verified implementation of a parallel work-stealing task scheduler (for any language) using realistic implementation techniques.
    Our experimental evaluation on a set of simple benchmarks shows that \Parabs has comparable or better performance than \Domainslib, and better performance than \Moonpool.
  \item
    A verified implementation of the DAG-calculus interface for parallel task graphs proposed by \citet{DBLP:conf/ppopp/AcarCR13}.
  \item
    At the level of \Iris proof techniques, we developed extensions of prophecy variables.
    To reason about the linearization points of our concurrent data structures we needed to introduce ``wise'' and ``multiplexed'' prophecy variables, which are reusable building blocks and could be useful for the verification of other concurrent data structures, in any \Iris formalization of any programming language.
\end{enumerate}

\paragraph{Artifact} The \Zoo verification framework supports a fragment of \OCaml called \ZooLang, with formal semantics defined as an \Iris program logic, and a partial translator from \OCaml to \ZooLang programs deeply embedded within \Rocq. Our developments are thus available as \OCaml libraries that are readily available for usage, and their \Rocq specifications, invariants and proofs. For reasons of space we cannot possibly hope to describe them in full in the paper, so we focus on the most readily reusable parts: specifications, and key invariants and proof techniques. For more details, we view our code and mechanized proofs as an integral part of this submission; they are available at \url{\refZoo}, publicly available and open-source.\footnote{For ease of development we followed the Zoo approach of working in a mono-repository, so we have an experimental version of Zoo with our developments added, as well as some cross-cutting improvements to the pre-existing support libraries and tactics.} To ease in-depth exploration, the paper contains direct references to the implementation and the proof as picture/icon links, for example \refLib{zoo_parabs/algo.ml} and \refTheories{zoo_parabs/algo.v}.
