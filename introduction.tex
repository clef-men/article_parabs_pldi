\section{Introduction}

The \OCaml programming language migrated from a sequential to a multicore runtime in \OCamlFive, imported from the \MulticoreOCaml research project~\citep*{DBLP:journals/pacmpl/Sivaramakrishnan20} and first released as \OCaml 5.0 in 2022. The sequential runtime had a ``big runtime lock'' guaranteeing that at most one OCaml thread would run at any point in time. The multicore runtime supports ``domains'' (heavyweight threads) that can run \OCaml code in parallel, operating on a shared heap and cooperating for garbage collection. It is designed to offer a M:N threading model with M lightweight tasks (or threads, fibers) are mapped to N domains, with N no larger than the number of CPU cores.\footnote{The multicore runtime of OCaml performs frequent stop-the-world pause in its garbage collector, to facilitate the migration of existing programs using the OCaml foreign function interface -- this design does not require adding a read barrier. A consequence of these stop-the-world events is that runtime performance declines sharply if a domain is paused by the operating system, so it is critical to limit the number of domains to available cores: domains are a heavier, less composable abstraction than ``kernel threads'' in typical M:N models. In consequence, they must be controlled by end-used applications, possibly via a concurrency framework that hides them entirely, and software libraries should not implicitly spawn new domains.} The implementation of lightweight tasks and their scheduler is left to be done in userland, as an OCaml library running on top of runtime-provided domains.

The authors of the \MulticoreOCaml runtime implemented the \Domainslib library for CPU-bound tasks, initially to write benchmarks to test the scalability of the \OCaml runtime. It uses a work-stealing scheduler and is state-of-the-art in the \OCaml library ecosystem. Other lightweight task libraries include \Moonpool, which was implemented independently, and \Eio which focuses on efficient asynchronous I/O.


